# 디자인 패턴이란? 
  : 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 
  수 있도록 하나의 '규약' 형태로 만들어 놓은 것.


  ---
## 1. 싱글톤 패턴

>### 설명
>
>- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
>- 보통 DB 연결 모듈에 많이 사용하며, 이외에도 도메인 관점에서 인스턴스가 한 개만 존재하는 것을 보증하고 싶은 경우에도 사용함.
>
> ### 특징
> 
> - 인스턴스 생성할 때 발생하는 비용 즉, **소모 메모리를 줄일 수 있음**. 
> ( → 하나의 인스턴스를 만들어놓고, 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문)
> - **접근 속도 향상**
> ( → 이미 생성된 인스턴스를 활용하기 때문)
> - **의존성이 높아진다는 단점**
> - 싱글톤 패턴을 구현하는 코드 자체가 많이 필요하다. 
> 앞서 소개한 구현 방법외에도 정적 팩토리 메서드에서 객체 생성을 확인하고 생성자를 호출하는 경우에 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 **syncronized** 키워드를 사용해야 한다.
> - **테스트하기 어렵다.**
> 싱글톤 인스턴스는 자원을 공유하고 있기 때문에 테스트가 결정적으로 격리된 환경에서 수행되려면 매번 인스턴스의 상태를 초기화시켜주어야 한다. 그렇지 않으면 어플리케이션 전역에서 상태를 공유하기 때문에 테스트가 온전하게 수행되지 못한다.
> - 의존 관계상 **클라이언트가 구체 클래스에 의존**하게 된다.
>  `new` 키워드를 직접 사용하여 클래스 안에서 객체를 생성하고 있으므로, 이는 SOLID 원칙 중 DIP를 위반하게 되고 OCP 원칙 또한 위반할 가능성이 높다.
> - 그 외 **자식클래스를 만들수 없다는 점** 과, **내부 상태를 변경하기 어렵다는 점** 등 여러가지 문제들이 존재한다. *결과적으로 이러한 문제들을 안고있는 싱글톤 패턴은 **유연성이 많이 떨어지는 패턴***이라고 할 수 있다.
> 
> ```jsx
> const obj = {
>   a: 27
> }
> 
> const obj2 = {
>   a: 27
> }
> 
> console.log(obj === obj2); // false
> ```
> 
> 위에서 obj, obj2 각각 객체는 **서로 다른 인스턴스**를 가진다. 그 이유는, 자바스크립트에서는 리터럴 `{}` 또는 `new Object`로 객체를 생성하게 되면 다른 어떤 객체와도 같지 않기 때문이다.
> 
> 따라서, 리터럴 {} 또는 new Object **자체만으로도** **싱글톤 패턴을 구현할 수 있다**.

## 2. 팩토리 패턴
>
>### 설명
>
>- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 **상위 클래스가 중요한 뼈대를 결정**하고, **하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정**하는 패턴이다.
>- 자바스크립트에서 팩토리 패턴을 구현한다면 간단하게 `new Object()`  로 구현할 수 있다.
>    
>    ```jsx
>    const num = new Object(42);
>    const str = new Object('abc');
>    
>    num.constructor.name; // Number
>    str.constructor.name; // String
>    ```
>    
>    - 숫자를 전달하거나 문자열을 전달함에 따라 다른 타입의 객체를 생성하는 것을 볼 수 있다. 이는 즉, 전달받은 값(인자)에 따라 가른 객체를 생성하며 인스턴스의 타입 등을 정한다.
>- 예를 들어 라떼 레시피와 아메리카노 레시피, 우유 레시피라는 구체적인 내용이 들어있는 하위 클래스가 컨베이어 벨트를 통해 전달되고, 상위 클래스인 바리스타 공장에서 이 레시피들을 토대로 우유 등을 생상하는 생상 공정을 생각하면 된다.
>    
>    ```jsx
>    class Latte {
>      constructor() {
>        this.name = "latte"
>      }
>    }
>    
>    class Espresso {
>      constructor() {
>        this.name = "Espresso"
>      }
>    }
>    
>    class LatteFactory { // 하위 클래스 (객체 생성에 관한 구체적인 내용 결정)
>      static createCoffee() {
>        return new Latte();
>      }
>    }
>    
>    class EspressoFactory { // 하위 클래스 (객체 생성에 관한 구체적인 내용 결정)
>      static createCoffee() {
>        return new Espresso();  // 여기서 인스턴스 생성하여 상위 클래스로 전달 (의존성 주입)
>      }
>    }
>    
>    const factoryList = { LatteFactory, EspressoFactory }
>    
>    class CoffeeFactory { // 상위 클래스 (뼈대 역할)
>      static createCoffee(type) {
>        const factory = factoryList[type]
>        return factory.createCoffee() // 의존성 주입
>      }
>    }
>    
>    const main = () => {
>      // 라떼 커피를 주문한다 
>      const coffee = CoffeeFactory.createCoffee('EspressoFactory')
>      //  커피 이름을 부른다
>      console.log(`주문하신 ${coffee.name} 나왔습니다`)
>    }
>    
>    main();
>    ```
>    
>    &#160;&#160;위의 예시 코드에서 CoffeeFactory 라는 상위 클래스가 **중요한 뼈대**를 결정하고, 하위 클래스인 EspressoFactory 가 **구체적인 내용**을 결정하고 있다.
>    참고로 이는 의존성 주입이라고도 볼 수 있는데, CoffeeFactory 클래스(상위 클래스)에서 EspressoFactory 클래스(하위클래스)의 인스턴스를 생성하는 것이 아닌 **EspressoFactory 클래스에서 생성한 인스턴스를 CoffeeFactory 클래스에 주입하고 있기 때문**이다.
>    
>
>### 특징
>
>- 보다 뛰어난 유연성을 가진다.
>( → **상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며** 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문)
>- 유지보수성이 뛰어나다.
>( → 객체 생성 로직이 따로 떼어져 있기 때문에 **코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되기 때문**이다)
 ## 의존성 주입 ( DI, Dependency Injection)
>   ### 설명
>   
>   ![image](https://user-images.githubusercontent.com/53039583/178137136-19484b8b-6269-4a75-8f88-cd602ffa6ac6.png)
>   
>   - 위의 그림처럼 메인 모듈이 ‘직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector) 가 이 부분을 가로채 메인 모듈이 ‘간접'적으로 의존성을 주입하는 방식.
>   - 이를 통해 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 되는데, 이를 ‘디커플링이 된다' 라고도 한다.
>   - 참고로 의존성이란, 종속성이라고도 하며 `A가 B에 의존성이 있다` 라는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미한다.
>   
>   ### 특징
>   
>   - 테스팅과 마이그레이션이 비교적 쉽다.
>   ( → 모듈들을 쉽게 교체할 수 있는 구조이기 때문)
>   - 애플리케이션 의존성 방향이 일관적이고, 애플리케이션을 쉽게 추론할 수 있으며 모듈 간의 관계들이 조금 더 명확해진다.
>   ( → 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기 때문)
>   - 복잡성 ⇧, 약간의 런타임 페널티가 발생할 수 있다.
>   ( → 모듈들이 더욱 더 분리되어 클래스 수가 늘어나므로)
>   
>   ### 의존성 주입 원칙
>   - 의존성 주입은 **의존성 주입 원칙**을 준수하며 만들어야 한다. 원칙은 아래와 같다.
>       - *상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다. 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 말아야 한다.*
>  - 위의 원칙을 이해하기 쉽게 조명 램프를 예를 들어보도록 하자.
>>   ```
>>   이번에 당신이 아주 고급진 램프를 하나 구매했다고 가정한다. 
>>   이 램프를 침대 옆에 두고 밤이 되면 램프를 끄고 잠에 들 것인데, 우리가 흔히 사용하는 램프의 사용패턴은 
>>   **스위치를 활용하여** 램프를 끄는 방식일 것이다.
>>   ```   
>>   ![image](https://user-images.githubusercontent.com/53039583/178137158-5e4dfd39-2133-41ef-9b36-3163595b58b3.png)
>>   ```
>>   그런데 시간이 지나서 이제 스위치뿐만 아니라 리모콘이나 스마트폰으로도 램프를 켜고 끌 수 있는 
>>   램프가 출시되었다고 생각을 해보자. 
>>   위와 같이 버튼에만 의존하여,즉 버튼만을 활용하는 램프는 
>>   새로 나온 램프의 기능(리모콘으로 램프를 켜고 끌 수 있는 기능)을 추가할 수 없을 것이다. 
>>   만약 추가한다고 하더라도  Lamp의 일부분을 뜯어 고쳐서 개조를 해야할 것이다.
>>   
>>   하지만 만약에 램프를 만들 때부터 "**켜고 끄는 기능**"을 **따로 모듈화 했었으면** 어땠을까? 
>>   그 켜고 끄는 기능을 현재는 버튼을 통해 구현을 했지만, 이후 더 좋은 기능이 나온다면 이는 
>>   리모콘, 스마트폰으로도 램프를 켜고 끄는 기능을 동작시킬 수 있을 것이다.
>>   ```
>>   
>> ![image](https://user-images.githubusercontent.com/53039583/178137163-a9e15683-9428-41b0-9c1c-9f33e046ac3e.png)
>> 
>> ```
>> 자 그렇다면 위의 설명이 이제 조금 이해가 갈 수도 있을 것이다.
>> 현재 상위 모듈(램프를 켜고 끌 수 있는 버튼)은 하위 모듈(램프)를 직접 참조 하지 않고 켜고 끌 수 있는 
>> 기능(Switchable)을 참조하여 기능을 구현하고 있다. 마찬가지로 Lamp도 Switchable을 참조하고 있다.
>> 
>> 이와 같이 상위 모듈/하위 모듈 간 참조 관계를 **인터페이스로 분리한다면 변동성이 큰 실제 구현체를 참조하지 
>> 않기에 상위 모듈에서 큰 코드 변경 없이 기능 변경을 할 수 있게 된다**.
>> ```