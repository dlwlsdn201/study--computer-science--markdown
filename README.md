# 디자인 패턴이란? 
  : 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 
  수 있도록 하나의 '규약' 형태로 만들어 놓은 것.


  ---
## 1. 싱글톤 패턴

>### 설명
>
>- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
>- 보통 DB 연결 모듈에 많이 사용하며, 이외에도 도메인 관점에서 인스턴스가 한 개만 존재하는 것을 보증하고 싶은 경우에도 사용함.
>
> ### 특징
> 
> - 인스턴스 생성할 때 발생하는 비용 즉, **소모 메모리를 줄일 수 있음**. 
> ( → 하나의 인스턴스를 만들어놓고, 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문)
> - **접근 속도 향상**
> ( → 이미 생성된 인스턴스를 활용하기 때문)
> - **의존성이 높아진다는 단점**
> - 싱글톤 패턴을 구현하는 코드 자체가 많이 필요하다. 
> 앞서 소개한 구현 방법외에도 정적 팩토리 메서드에서 객체 생성을 확인하고 생성자를 호출하는 경우에 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 **syncronized** 키워드를 사용해야 한다.
> - **테스트하기 어렵다.**
> 싱글톤 인스턴스는 자원을 공유하고 있기 때문에 테스트가 결정적으로 격리된 환경에서 수행되려면 매번 인스턴스의 상태를 초기화시켜주어야 한다. 그렇지 않으면 어플리케이션 전역에서 상태를 공유하기 때문에 테스트가 온전하게 수행되지 못한다.
> - 의존 관계상 **클라이언트가 구체 클래스에 의존**하게 된다.
>  `new` 키워드를 직접 사용하여 클래스 안에서 객체를 생성하고 있으므로, 이는 SOLID 원칙 중 DIP를 위반하게 되고 OCP 원칙 또한 위반할 가능성이 높다.
> - 그 외 **자식클래스를 만들수 없다는 점** 과, **내부 상태를 변경하기 어렵다는 점** 등 여러가지 문제들이 존재한다. *결과적으로 이러한 문제들을 안고있는 싱글톤 패턴은 **유연성이 많이 떨어지는 패턴***이라고 할 수 있다.
> 
> ```jsx
> const obj = {
>   a: 27
> }
> 
> const obj2 = {
>   a: 27
> }
> 
> console.log(obj === obj2); // false
> ```
> 
> 위에서 obj, obj2 각각 객체는 **서로 다른 인스턴스**를 가진다. 그 이유는, 자바스크립트에서는 리터럴 `{}` 또는 `new Object`로 객체를 생성하게 되면 다른 어떤 객체와도 같지 않기 때문이다.
> 
> 따라서, 리터럴 {} 또는 new Object **자체만으로도** **싱글톤 패턴을 구현할 수 있다**.

>### 2. 팩토리 패턴
>
>### 설명
>
>- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 **상위 클래스가 중요한 뼈대를 결정**하고, **하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정**하는 패턴이다.
>- 자바스크립트에서 팩토리 패턴을 구현한다면 간단하게 `new Object()`  로 구현할 수 있다.
>    
>    ```jsx
>    const num = new Object(42);
>    const str = new Object('abc');
>    
>    num.constructor.name; // Number
>    str.constructor.name; // String
>    ```
>    
>    - 숫자를 전달하거나 문자열을 전달함에 따라 다른 타입의 객체를 생성하는 것을 볼 수 있다. 이는 즉, 전달받은 값(인자)에 따라 가른 객체를 생성하며 인스턴스의 타입 등을 정한다.
>- 예를 들어 라떼 레시피와 아메리카노 레시피, 우유 레시피라는 구체적인 내용이 들어있는 하위 클래스가 컨베이어 벨트를 통해 전달되고, 상위 클래스인 바리스타 공장에서 이 레시피들을 토대로 우유 등을 생상하는 생상 공정을 생각하면 된다.
>    
>    ```jsx
>    class Latte {
>      constructor() {
>        this.name = "latte"
>      }
>    }
>    
>    class Espresso {
>      constructor() {
>        this.name = "Espresso"
>      }
>    }
>    
>    class LatteFactory { // 하위 클래스 (객체 생성에 관한 구체적인 내용 결정)
>      static createCoffee() {
>        return new Latte();
>      }
>    }
>    
>    class EspressoFactory { // 하위 클래스 (객체 생성에 관한 구체적인 내용 결정)
>      static createCoffee() {
>        return new Espresso();  // 여기서 인스턴스 생성하여 상위 클래스로 전달 (의존성 주입)
>      }
>    }
>    
>    const factoryList = { LatteFactory, EspressoFactory }
>    
>    class CoffeeFactory { // 상위 클래스 (뼈대 역할)
>      static createCoffee(type) {
>        const factory = factoryList[type]
>        return factory.createCoffee() // 의존성 주입
>      }
>    }
>    
>    const main = () => {
>      // 라떼 커피를 주문한다 
>      const coffee = CoffeeFactory.createCoffee('EspressoFactory')
>      //  커피 이름을 부른다
>      console.log(`주문하신 ${coffee.name} 나왔습니다`)
>    }
>    
>    main();
>    ```
>    
>    &#160;&#160;위의 예시 코드에서 CoffeeFactory 라는 상위 클래스가 **중요한 뼈대**를 결정하고, 하위 클래스인 EspressoFactory 가 **구체적인 내용**을 결정하고 있다.
>    참고로 이는 의존성 주입이라고도 볼 수 있는데, CoffeeFactory 클래스(상위 클래스)에서 EspressoFactory 클래스(하위클래스)의 인스턴스를 생성하는 것이 아닌 **EspressoFactory 클래스에서 생성한 인스턴스를 CoffeeFactory 클래스에 주입하고 있기 때문**이다.
>    
>
>### 특징
>
>- 보다 뛰어난 유연성을 가진다.
>( → **상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며** 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문)
>- 유지보수성이 뛰어나다.
>( → 객체 생성 로직이 따로 떼어져 있기 때문에 **코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되기 때문**이다)